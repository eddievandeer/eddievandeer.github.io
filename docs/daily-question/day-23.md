---
title: Day-23 寻找矩阵中权重最大的路径
postTime: 2022-02-15
categories: 每日一题
tags: 
- 矩阵
- 动态规划
---

::: slot abstract

**题目：**

~~~
在一个棋盘上，每个格子放着不同价值的礼物（礼物价值大于0），一个人初始位置在棋盘的左上角，每次他只能向下或者向右移动一步，并拿走对应格子上的礼物，结束位置在棋盘的右下角，请设计一个算法使其能够获得最大价值的礼物
~~~

这道题目翻译一下其实意思就是：给定一个矩阵，矩阵上的每个点有一个大于 0 的值，要求找到矩阵中，值的和最大的路径

像这种需要用到前面的计算结果的题目类型，第一时间就应该联想到 **动态规划** 了

:::



## 寻找矩阵中权重最大的路径

### 题目

~~~
在一个棋盘上，每个格子放着不同价值的礼物（礼物价值大于0），一个人初始位置在棋盘的左上角，每次他只能向下或者向右移动一步，并拿走对应格子上的礼物，结束位置在棋盘的右下角，请设计一个算法使其能够获得最大价值的礼物
~~~



### 解答

这道题目翻译成 “人话” 其实意思就是：给定一个矩阵，矩阵上的每个点有一个大于 0 的值，要求找到矩阵中，值的和最大的路径。像这种需要用到前面的计算结果的题目类型，第一时间就应该联想到 **动态规划** 了。首先还是经典的三步走：

- **状态定义**

  设动态规划列表 `dp` ，`dp[i][j]` 代表坐标 `(i, j)` 上能拿到的最大价值

- **转移方程**

  因为只能从左或上两个方向到达一个格子，所以 `dp[i][j]` 的值为左侧值和上边值中的最大值再加上矩阵在坐标 `(i, j)` 下的值，即：`max(dp[i][j - 1], dp[i - 1][j]) + matrix[i][j]`

- **边界条件**

  当坐标的 `i = 0` 时，因为无法从上方移动到这一格，所以 `dp[i][j]` 的值为：矩阵在坐标 `(0, j)` 下的值加左侧坐标能拿到的最大价值，即：`matrix[i][j] + dp[i][j - 1]`

  当坐标的 `j = 0` 时，因为无法从左侧移动到这一格，所以 `dp[i][j]` 的值为：矩阵在坐标 `(i, 0)` 下的值加上边坐标能拿到的最大价值，即：`matrix[i][j] + dp[i - 1][j]`

代码实现：

~~~js
function getMaxPath(matrix) {
    const row = matrix.length
    const column = matrix[0].length

    const dp = new Array(row).fill(0).map(() => new Array(column).fill(0))

    dp[0][0] = matrix[0][0]

    // 初始化dp的第一行
    for(let i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + matrix[i][0]
    }

    // 初始化dp的第一列
    for(let j = 1; j < column; j++) {
        dp[0][j] = dp[0][j - 1] + matrix[0][j]
    }

    for(let i = 1; i < row; i++) {
        for(let j = 1; j < column; j++) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]
        }
    }
    
    return dp[row - 1][column  -1]
}
~~~

这里其实还有优化的空间， `dp` 这个数组并不需要创建成二维的，我们只需要一维就够了，然后每次获取旧的值来计算，并使用新的值去替换。代码如下：

~~~js
function getMaxPath(matrix) {
    const dp = new Array(row).fill(0)

    dp[0] = matrix[0][0]

    for(let i = 1; i < row; i++) {
        dp[i] = dp[i - 1] + matrix[i][0]
    }

    for(let i = 1; i < row; i++) {
        for(let j = 0; j < column; j++) {
            if(j == 0) {
                dp[j] = dp[j] + matrix[i][j]
            } else {
                dp[j] = Math.max(dp[j], dp[j - 1]) + matrix[i][j]
            }
        }
    }
    
    return dp[row - 1]
}
~~~



### 扩展

现在增加一个限制，移动方式还是和前面的一样，但拿到的总礼物价值不得超过一个限定值 `limit` ，以此设计一个算法实现
